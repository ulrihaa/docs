# Визуализировать данные в {{ datalens-name }} с помощью {{ sf-name }}

Вы можете передавать ответы на форму в базу данных PostgreSQL, созданную в {{ yandex-cloud }}, и визуализировать их в сервисе {{ datalens-full-name }}.

С помощью этой инструкции вы сможете визуализировать:
* Количество ответов на форму, распределенное по датам.
* Статистику ответов на вопросы с типом **Короткий текст** и **Один вариант**, распределенное по датам.

## Шаг 1. Создать базу данных

1. Перейдите в [консоль {{ yandex-cloud }}]({{ link-console-main }}) и выберите каталог, в котором хотите создать базу данных.
1. На панели слева нажмите ![](../_assets/organization/icon-services-menu.svg) и выберите сервис {{ mpg-full-name }}.
1. В правом верхнем углу нажмите **Создать кластер**.
1. Настройте кластер:
	1. В разделе **Базовые параметры** заполните поле **Имя кластера**. Оно может содержать строчные и прописные буквы латинского алфавита, цифры, нижние подчеркивания и дефисы.
	1. В разделе **База данных** заполните поля **Имя БД** и **Имя пользвателя**. Они могут содержать строчные и прописные буквы латинского алфавита, цифры, нижние подчеркивания и дефисы.
	1. В разделе **База данных** заполните поле **Пароль**.
	1. В разделе **База данных** в полях **Локаль сортировки (LC_COLLATE)** и **Локаль набора символов (LC_CTYPE)** установите значение **en_US.UTF8**. После создания базы данных изменить эти параметры не получится.
	1. В разделе **Дополнительные настройки** включите опции **Доступ из консоли управления**, **Доступ из Serverless** и **Доступ из DataLens**.
	1. При желании настройте другие параметры. Подробнее в разделе [{#T}](../managed-postgresql/operations/cluster-create.md).
1. Нажмите **Создать кластер**.
1. Дождитесь, когда в у нового кластера поле **Доступность** примет значение **Alive**.

## Шаг 2. Создать таблицы

1. Перейдите на страницу созданного кластера.
1. На панели слева нажмите **SQL**.
1. Выберите подходящее имя пользователя и базу данных, введите пароль и нажмите **Подключиться**.
1. Выберите схему **public**.
1. Выполните SQL-запросы, чтобы создать таблицы:
	1. Таблица для хранения всех ответов на форму:
		```sql
		create table answers(
			id serial primary key,
			answer jsonb,
			created timestamp with time zone default now()
		);
		```
	1. Таблица для подсчета количества ответов на форму:
		```sql
		create table answercount(
  			id serial primary key,
  			survey_id text not null,
  			modified date not null default current_date,
  			count int default 0,
  			unique(survey_id, modified)
		);
		```
	1. Таблица для хранения ответов на вопросы с типом **Короткий текст** и **Один вариант**.
		```sql
		create table questioncount(
  			id serial primary key,
			survey_id text not null,
			question_key text not null,
			option_key text not null default '',
			modified date not null default current_date,
			count int default 0,
			unique(survey_id, question_key, option_key, modified)
		);
		```

## Шаг 3. Создать подключение к базе данных

1. В [консоли]({{ link-console-main }}) перейдите обратно в каталог, в котором находится созданный кластер.
1. На панели слева нажмите ![](../_assets/organization/icon-services-menu.svg) и выберите сервис {{ sf-name }}.
1. На панели слева нажмите ![](../_assets/forms/svg/database-connect.svg).
1. В правом верхнем углу нажмите **Создать подключение**.
1. Настройте подключение:
	1. Заполните поле **Имя**. Оно может содержать только строчные буквы латинского алфавита, цифры и дефисы.
	1. В поле **Тип** выберите **PostgreSQL**.
	1. Запоните поля **Кластер**, **База данных**, **Пользователь** и **Пароль**. Введите в них те значения, которые устанавливали при создании кластера в шаге 1.
1. Нажмите **Создать**.
1. Перейдите на страницу подключения и скопируйте значение поля **Точка входа**.

## Шаг 4. Создать сервисный аккаунт

1. В [консоли]({{ link-console-main }}) перейдите обратно в каталог, в котором находится созданный кластер.
1. В правом верхнем углу нажмите ![](../_assets/forms/svg/settings.svg) → **Создать сервисный аккаунт**.
1. В окне создания сервисного аккаунта заполните поля:
	1. **Имя** может содержать только строчные буквы латинского алфавита, цифры и дефисы.
	1. **Описание** может содержать любые символы.
	1. В поле **Роли в каталоге** добавьте следующие роли:
		* `serverless.functions.invoker`
		* `serverless.mdbProxies.user`
1. Нажмите **Создать**.

## Шаг 5. Создать ключ сервисного аккаунта

1. В [консоли]({{ link-console-main }}) перейдите обратно в каталог, в котором находится созданный кластер.
1. Перейдите на вкладку **Сервисные аккаунты**.
1. Выберите нужный аккаунт.
1. На странице аккаунта на верхней панели нажмите **Создать новый ключ** → **Создать API-ключ**.
1. Напишите краткое описание ключа.
1. Нажмите **Создать**.
1. Откроется окно с идентификатором ключа и секретным ключом. Сохраните их в безопасном месте. После закрытия окна доступ к ним получить нельзя.

## Шаг 6. Создать облачную функцию

1. В [консоли]({{ link-console-main }}) перейдите обратно в каталог, в котором находится созданный кластер.

1. На панели слева нажмите ![](../_assets/organization/icon-services-menu.svg) и выберите сервис {{ sf-name }}.

1. В правом верхнем углу нажмите **Создать функцию**.

1. На странице создания функции заполните поля:
	1. **Имя** может содержать только строчные буквы латинского алфавита, цифры и дефисы.
	1. **Описание** может содержать любые символы.

1. Выберите язык программирования Python.

1. Создайте файл `requirements.txt` и напишите в нем строку:
	```
	psycopg2
	```

1. Создайте или отредактируйте файл `index.py`:
	
	```python
	import json
	import psycopg2

	def get_connection(context):
		return psycopg2.connect(
			database="<идентификатор подключения>",
			user="<имя пользователя>",
			password=context.token["access_token"],
			host="<точка входа>",
			port=6432,
			sslmode="require",
		)

	def run_function(connection, answer, **params):
		survey_id = answer['survey']['id']
		args = (survey_id, )

		with connection.cursor() as c:
			sql = '''
				insert into answercount as t (survey_id, count) 
				values(%s, 1)
				on conflict (survey_id, modified) 
				do update set count = t.count + excluded.count
			'''
			c.execute(sql, args)

		args, args_size = [], 0
		for question_key, question_data in answer['data'].items():
			match question_data['question']['answer_type']['slug']:
				case 'answer_choices':
					for choice_item in question_data['value']:
						args.extend([survey_id, question_key, choice_item['key']])
						args_size += 1
				case 'answer_short_text':
					args.extend([survey_id, question_key, ''])
					args_size += 1

		with connection.cursor() as c:
			values = ','.join(['(%s, %s, %s, 1)'] * args_size)
			sql = '''
				insert into questioncount as t (survey_id, question_key, option_key, count) 
				values{values}
				on conflict (survey_id, question_key, option_key, modified) 
				do update set count = t.count + excluded.count
			'''.format(values=values)
			c.execute(sql, args)
			
		connection.commit()
	
	def handler(event, context):
    	body = json.loads(event.get('body'))
		params = {
			name: value
			for name, value in body.items()
			if name != 'answer'
		}
		connection = get_connection(context)
		result = {
			'id': run_function(connection, body.get('answer'), **params),
		}

		return {
			'statusCode': 200,
			'body': result,
			'headers': {
				'Content-Type': 'application/json',
			}
		}
	```
	
	В этой функции подставьте значения:
	* `<идентификатор подключения>` — значение поля **Идентификатор** подключения к базе данных, которое вы создавали в шаге 3. Скопировать его можно на странице подключения.
	* `<имя пользователя>` — имя пользователя базы данных, которое вы вводили при настройке кластера в шаге 1. Найти его можно на странице кластера во вкладке **Пользователи**.
	* `<точка входа>` — значение поля **Точка входа** в подключении к базе данных, которое вы создавали в шаге 3. Скопировать его можно на странице подключения.

1. Нажмите **Сохранить изменения**.

1. На странице функции скопируйте значение ее поля **Идентификатор**.

## Шаг 7. Настроить интеграцию

1. Перейдите в форму, ответы на которую хотите передавать в базу данных, и выберите вкладку **Интеграции**.
1. Выберите группу действий, в которой хотите настроить создание задачи, и внизу группы нажмите кнопку {{ sf-name }}.
1. В поле **Код функции** вставьте идентификатор функции, который скопировали в предыдущем шаге.
1. При желании в разделе **Параметры** выберите дополнительные параметры, которые хотите передать в функцию.
1. Нажмите **Сохранить**.

## Шаг 8. Подключить {{ datalens-name }} к базе данных

1. В [консоли]({{ link-console-main }}) перейдите обратно в каталог, в котором находится созданный кластер.
1. На панели слева нажмите ![](../_assets/organization/icon-services-menu.svg) и выберите сервис {{ datalens-name }}.
1. Нажмите **Содать подключение** → **PostgreSQL**.
1. Настройте подключение:
	1. В поле **Облако и каталог** выберите каталог, в котором создали кластер.
	1. В поле **Кластер** выберите кластер, который создали в шаге 1.
	1. В поле **Имя хоста** выберите хост.
	1. В поле **Путь к базе данных** выберите имя базы данных, в которой создавали таблицы в шаге 2.
	1. В поле **Имя пользователя** выберите пользователя, которого создавали вместе с кластером в шаге 1.
	1. В поле **Пароль** введите пароль, который создавали в шаге 1.
1. Нажмите **Создать подключение**.

## Шаг 9. Создать чарт

1. В правом верхнем углу нажмите **Создать датасет**.
1. Перетащите таблицу `public.answercount` в область посередине страницы.
1. В правом верхнем углу нажмите **Создать чарт**.
1. Перетащите названия столбцов таблицы из раздела **Измерения** на панель **Столбчатая диаграмма** следующим образом:
	* `modified` — в поле **X**.
	* `count` — в поле **Y**.
	* `survey_id` — в поле **Фильтры**.
1. Нажмите **Сохранить**.

## Шаг 10. Создать дашборд

1. Перейдите обратно на страницу {{ datalens-name }}.
1. Нажмите **Создать дашборд**.
1. Выберите каталог, в котором будет создан дашборд, введите его название и нажмите **Создать**.
1. На панели сверху нажмите **Добавить** → **Чарт**.
1. В окне добавления чарта:
	1. Заполните поле **Название**.
	1. В поле **Чарт** выберите чарт, созданный в шаге 9.
	1. Нажмите **Добавить**.
1. В правом верхнем углу нажмите **Сохранить**.

У вас готова столбчатая диаграмма с количеством ответов на форму в зависимости от даты.

## Шаг 11. Настроить диаграмму

1. Перейдите на страницу кластера, который создавали в шаге 1.
1. На панели слева нажмите **SQL**.
1. Выберите подходящее имя пользователя и базу данных, введите пароль и нажмите **Подключиться**.
1. Выберите схему **public**.
1. Выполните следующий SQL-запрос:
	1. Создайте таблицу, в которой будет храниться информация о цветах диаграммы:
		```sql
		create table labels(
			id serial primary key,
			compound_key text not null,
			label text default '',
			unique(compound_key)
		);
		```
	1. Добавьте в эту таблицу информацию о лейблах для вариантов ответа:
		```sql
		insert into labels(compound_key, label)
		values('id-radio.62019338', 'Option 1'), ('id-radio.62019364', 'Option 2'), ('id-radio.62019365', 'Option 3');
		```
	1. Создайте представление, в котором будут связаны идентификатор вопроса и идентификатор варианта ответа.
		```sql
		create view questioncount_vw as
		select t.*, 
			case 
				when t.option_key = '' or t.option_key is null then t.question_key
				else t.question_key || '.' || t.option_key
			end as compound_key
		from questioncount t;
		```

## Шаг 12. Настроить отображение цветов на диаграмме 

1. Перейдите на страницу {{ datalens-name }} и перейдите в подключение, которое создали в шаге 8.
1. В правом верхнем углу нажмите **Создать датасет**.
1. Перетащите таблицу `public.questioncount_vw` на середину страницы.
1. Перетащите таблицу `public.labels` на середину страницы.
1. Между названиями таблиц посередине страницы нажмите ![](../_assets/forms/datalens-inner-join.png =16x).
1. В открывшемся окне нажмите ![](../_assets/forms/datalens-inner-join.png =16x) еще раз, выберите значение **left** по полю `compound key` и нажмите **Сохранить**.
1. Перейдите на вкладку **Поля**.
1. На панели сверху нажмите **Добавить поле**.
1. Заполните окно создания поля:
	1. В поле **Название поля** введите `question_label`.
	1. В основной части поля введите:
		```
		if [label] is not null then [label] else [compound key (1)] end
		```
	1. Нажмите **Сохранить**.
1. На панели сверху нажмите **Создать чарт**.
Перетащите названия из раздела **Измерения** на панель **Столбчатая диаграмма** следующим образом:
	* `modified` — в поле **X**.
	* `count` — в поле **Y**.
	* `question_label` — в поле **Цвета**.
	* `survey_id` и `question_key` — в поле **Фильтры**.
1. Нажмите **Сохранить**.

## Шаг 13. Разместить новый чарт на дашборде

1. Перейдите в дашборд, который создали в шаге 10.
1. На панели сверху нажмите **Добавить** → **Чарт**.
1. В окне добавления чарта:
	1. Заполните поле **Название**.
	1. В поле **Чарт** выберите чарт, созданный в шаге 12.
	1. Нажмите **Добавить**.
1. В правом верхнем углу нажмите **Сохранить**.

Теперь на вашем дашборде есть две похожих столбчатых диаграммы одноцветная и разноцветная, цвета которое зависят от ответов, которые выбирали пользователи.

## Шаг 14. Установить автообновление дашборда

1. На панели сверху нажмите ![](../_assets/forms/svg/settings-2.svg).
1. В открывшемся окне включите опцию **Автообновление** и задайте интервал времени между обновлениями дашборда.
1. Нажмите **Сохранить**.